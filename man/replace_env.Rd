% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/replace_env.R
\name{replace_env}
\alias{replace_env}
\title{Replace one of the parent environments with another}
\usage{
replace_env(envir, search, replace, update_parent = TRUE)
}
\arguments{
\item{search}{A \code{\link[base:environment]{environment}},
among the parents of \code{envir}, to be replaced.
It is possible to specify a list of alternative environments.}

\item{replace}{A \code{\link[base:environment]{environment}}.}

\item{update_parent}{If TRUE, or 1L, the parent environment of
\code{replace} is set to the parent environment of the replaced
"search" environment. If FALSE, or 0L, it is not updated.
If a positive integer greater than one, then that parent
generation is updated, e.g. \code{update_parent = 2L} will update
the parent environment of the \emph{parent} of \code{replace}.}
}
\value{
Invisibly, the replaced environment.
}
\description{
Replace one of the parent environments with another
}
\section{Serialization of functions}{


Consider below function \code{f()} where \code{pi} is part of \code{environment(f)},
which is a local environment, and \code{a} is a global variable part of
\code{parent_env(f)}.

\if{html}{\out{<div class="sourceCode r">}}\preformatted{cargo <- rnorm(1e6)
a <- 2
f <- local(\{
  pi <- 3.14
  function() \{
    n <- 4
    a * pi / n
  \}
\})
}\if{html}{\out{</div>}}

We can visualize this as:

\if{html}{\out{<div class="sourceCode">}}\preformatted{+----------------------+
| parent_env(f):       |
| cargo = \{ 1e6 \}      |
| a = 2                |
| f                    |
+----------------------+
           ^
           |
+----------------------+
| environment(f):      |
| pi = 3.14            |
+----------------------+
           ^
           |
+======================+
| f():                 | (frame at runtime)
| n = 4                |
+======================+
}\if{html}{\out{</div>}}

In order to evaluate \code{f()}, variables \code{a} and \code{pi}, which are global
("free") variables defined outside and not at runtime in the call
frame, like \code{n} is.  To clarify further what the difference is:
we cannot query \code{n} from \code{f}, but we can query both \code{pi} and \code{a} as
\code{environment(f)$pi} and \code{parent_env(f)$a}.
Similarly, we can also do \code{parent_env(f)$cargo}, but it is a variable
useless for evalating \code{f()}.

When we serialize \code{f} (e.g. export it to a parallel worker), the body
and the formals of the function is included, as well as all
the environments of \code{f} up to where \code{f} itself lives, e.g.
\code{environment(f)} and \code{parent_env(f)} in our example.
However, if the environment where \code{f} lives is the global environment
(= \code{globalenv()}), then it is \emph{not} part of the serialization output.
Imagine we save \code{f} to file, restart R, and load it back, e.g.

\if{html}{\out{<div class="sourceCode r">}}\preformatted{saveRDS(f, "f.rds")
quit(save = "no")
f <- readRDS(f)
}\if{html}{\out{</div>}}

In this case, we will lose \code{a} and \code{cargo}, which is good and bad.
It's bad, because we need to bring \code{a} back, in order to evaluate \code{f()},
e.g.

\if{html}{\out{<div class="sourceCode r">}}\preformatted{f()
#> Error in f() : object 'a' not found
}\if{html}{\out{</div>}}

It's good, because we don't have to pay the price of serializing the
large \code{cargo} object.  Continuing, our unserialized \code{f()} looks like:

\if{html}{\out{<div class="sourceCode">}}\preformatted{+----------------------+
| parent_env(f):       | (= globalenv())
| f                    |
+----------------------+
           ^
           |
+----------------------+
| environment(f):      |
| pi = 3.14            |
+----------------------+
           ^
           |
+======================+
| f():                 | (frame at runtime)
| n = 4                |
+======================+
}\if{html}{\out{</div>}}

One way to revive \code{a} is to inject a new grandparent environment that
holds a copy of \code{a}, e.g.

\if{html}{\out{<div class="sourceCode r">}}\preformatted{new <- new.env(parent = parent_env(f))
new$a <- 2
parent.env(environment(f)) <- new
}\if{html}{\out{</div>}}

\if{html}{\out{<div class="sourceCode">}}\preformatted{+-----------------------+
| parent_env(f, n = 2): | (= globalenv())
| f                     |
+-----------------------+
           ^
           |
+-----------------------+
| parent_env(f):        | (injected environment)
| a = 2                 |
+-----------------------+
           ^
           |
+-----------------------+
| environment(f):       |
| pi = 3.14             |
+-----------------------+
           ^
           |
+=======================+
| f():                  | (frame at runtime)
| n = 4                 |
+=======================+
}\if{html}{\out{</div>}}

and we can evaluate \code{f()} again;

\if{html}{\out{<div class="sourceCode r">}}\preformatted{f()
#> 1.57
}\if{html}{\out{</div>}}

We can of course build up the above version of \code{f()} \emph{before} serializing,
e.g before we save to file above. Then it is ready to use when
unserialized, e.g. read back from file.
An alternative way to achive this is to use the \code{replace_env()} function;

\if{html}{\out{<div class="sourceCode r">}}\preformatted{new <- as.environment(list(a = a))
replace_env(f, search = locate_object(f)$envir, replace = new)
}\if{html}{\out{</div>}}

If we save this to file, restart R, and load it back in, we'll see that
we have a fully functional version of \code{f}, e.g. \code{f()} gives 1.57.

Another, less verbose, alternative is to use \code{\link[=prune_fcn]{prune_fcn()}};

\if{html}{\out{<div class="sourceCode r">}}\preformatted{globals <- list(a = a)
prune_fcn(f, globals = globals)
}\if{html}{\out{</div>}}

And we can even identify global variables automatically:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{prune_fcn(f, globals = get_globals(f))
}\if{html}{\out{</div>}}

which is the same as the default:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{prune_fcn(f)
}\if{html}{\out{</div>}}
}

\examples{
a <- 42
f <- local(function() a)

f_envs <- parent_envs(f, until = environment(), extra = 1L)
names(f_envs)
y <- f()
y

new <- as.environment(list(a = 13, pi = 3.14))
old <- replace_env(f, search = environment(), replace = new)
old

f2_envs <- parent_envs(f, until = list(environment(), parent_env()))
names(f2_envs)

## Note that f() will now see a = 13 in the replaced environment
## rather than a = 42 in the calling environment
z <- f()
z

## Undo changes
old2 <- replace_env(f, search = new, replace = old)
stopifnot(identical(old2, new))

f3_envs <- parent_envs(f, until = environment(), extra = 1L)
stopifnot(identical(f3_envs, f_envs))

## f() will now see a = 42 again
z <- f()
z

## ------------------------------------------------------------------------
## Example how to avoid huge local objects being part of a local function,
## which might be costly if the function is serialized, e.g. exported
## to a parallel workers
## ------------------------------------------------------------------------

## Call a function with the option to replace the function
## environment with a smaller temporary environment
do_call <- function(fcn, args = list(), envir = parent.frame(),
                    prune = FALSE) {
  if (prune) {
    fcn_where <- locate_object(fcn, from = envir, first = FALSE)
    fcn_globals <- get_globals(fcn)
    new <- as.environment(fcn_globals)
    old <- replace_env(fcn, search = fcn_where$envir, replace = new)
    on.exit(replace_env(fcn, search = new, replace = old))
  }
  
  message(sprintf("Size of '\%s': \%s bytes",
          as.character(substitute(fcn)), size_of(fcn)))
 
  do.call(fcn, args = args, envir = envir)
}

my_fcn <- function(prune = FALSE) {
  cargo <- rnorm(1e6)
  
  n <- 2
  g <- local({
    pi <- 3.14
    function() n * pi
  })
  
  do_call(g, prune = prune)
}

my_fcn()
my_fcn(prune = TRUE)

n <- 2  
g <- local({
  pi <- 3.14
  function() n * pi
})

my_fcn <- function(prune = FALSE) {
  cargo <- rnorm(1e6)
  do_call(g, prune = prune)
}

my_fcn()
my_fcn(prune = TRUE)


cargo <- rnorm(1e6)
n <- 2  
g <- local({
  pi <- 3.14
  function() n * pi
})

my_fcn <- function(prune = FALSE) {
  do_call(g, prune = prune)
}

my_fcn()
my_fcn(prune = TRUE)

rm(list = c("cargo", "n"))


## WARNING: Large objects inside local environments of
##          the function will not the pruned!
g <- local({
  cargo <- rnorm(1e6)
  n <- 2  
  local({
    pi <- 3.14
    function() n * pi
  })
})

my_fcn <- function(prune = FALSE) {
  do_call(g, prune = prune)
}

my_fcn()
my_fcn(prune = TRUE)
}
